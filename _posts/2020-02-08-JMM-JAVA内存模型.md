---
layout:     post
title:      JAVA 内存模型介绍
subtitle:   JMM-Java Memory Model 的缘起由来、及特性先行发生原则
date:       2020-02-08
author:     Admin
header-img: assets/post-bg-java-2.jpg
catalog: true
tags:
    - Java
    - JMM
---

#### 前言
很多时候我们会把JMM跟JVM混淆在一起，所以面试的时候很容易被面试官问懵逼，所以借鉴了《深入理解JAVA虚拟机》这本书，对Java内存模型做个整理。


#### 概述
由于现在计算机的运算能力强大了，它的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如何使用一些手段去把处理器的运算能力“压榨”出来，不让处理器大部分时间里都处于等待其他资源的状态，让计算机同时处理几项任务则是最容易想到的的手段。

#### 硬件的效率与缓存一致性
* 先从计算机的硬件效率说起，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所有现代计算机都不得部加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中，这样处理器就无须等待缓慢的内存读写了。
* 缓存一致性问题：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这样当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？这样就需要各个处理器访问缓存时都遵循一些协议（MSI、MESI、MOSI...）。
如图：处理器、高速缓存、主内存间的交互关系
![37e3195ba16743485c453e818476bdec](https://github-io-blog.oss-cn-shanghai.aliyuncs.com/github-blog/blog-img-2020/java-jmm-1581518618495.png?x-oss-process=style/watermark-yumi)

* 除了增加高速缓存外，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后讲乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。

#### Java内存模型
* Java内存模型的主要目标是定义程序中各个变量（与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题）的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
* 这个模型的特征是围绕在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。
* **主内存与工作内存**
    * java内存模型规定了所有的变量都存储在主内存中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅时虚拟机内存的一部分）。每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝（这个对象的引用，对象中某个线程访问到字段是有可能存在拷贝，但不会有虚拟机实现成把整个对象拷贝一次），线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。
    * 线程、主内存、工作内存三者的交互关系如图：![e15ea5b9c5264faef6d33c1a6b5db98a](https://github-io-blog.oss-cn-shanghai.aliyuncs.com/github-blog/blog-img-2020/java-jmm-1581518541498.png?x-oss-process=style/watermark-yumi)


* **内存间的交互操作：**
    * java内存模型中定义了8种操作来完成主内存与工作内存之间的交互协议，每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load,store,read和write操作在某些平台上允许有例外）。
    * 八种基本操作：
        * 1. **lock**（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
        * 2. **unlock**（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
        * 3. **read**（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
        * 4. **load**（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
        * 5. **use**（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
        * 6. **assign**（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
        * 7. **store**（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用。
        * 8. **write**（写入）:作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
    * 八种基本操作必须满足如下的规则：
        *  不允许read和load、store和write操作之一单独出现，既不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
        *  不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
        *  不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
        *  一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use,store操作之前，必须先执行过了assign和load操作。
        *  一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
        *  如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
        *  如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
        *  对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store,write操作）。


#### volatile修饰的变量（指令重排序、内存屏障）
1. volatile第一条语义保证此变量对所有线程的可见性，由于volatie变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。
    * 1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
    * 2. 变量不需要与其他的状态变量共同参与不变约束。

2. volatile第二条语义时禁止指令重排序优化。
普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是java内存模型中描述的所谓“线程内表现为串行的语义”

3. 指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序.

4. 理解：假设定义个布尔类型的initialized的变量，在线程A中执行了一些获取配置信息后，将最后代码initialized设置为true。线程B中等待initialized为true后，代表线程A已经把配置信息初始化完成，如果没有加volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码“initialized=true”被提前执行，这样在线程B中使用配置信息的代码就可能出错。（所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行）
通过加volatile和不加volatile所生成的汇编语言的差别发现：volatile修饰后多执行了一个"lock addl"操作，这个操作相当于内存屏障，指重排序不能把后面的指令重排序到内存屏障之前的位置。只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。
5. volatile的意义能让我们的代码比使用其他的同步工具更快吗？
    * 由于虚拟机对锁实行的许多消除和优化，很难量化的认为volatile就会比synchronized快多少。在多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。

#### 原子性、可见性与有序性
**原子性：** Java内存模型来直接保证原子性变量的操作包括read,load,assign,use,store,write，大致认为基本数据类型访问读写是具备原子性的（例外就是long和double的非原子性协定），java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到java代码中就是同步块--synchronized关键字，因此synchronized块之间的操作也具备原子性。

**可见性：** 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。除了volatile保证了多线程操作时变量的可见性，还有synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把"this"的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。

**有序性：** Java程序中天然的有序性总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序出现乱序”现象和“工作内存与主内存同步延迟”现象。

#### 先行发生原则（happens-before）
如果光靠sychronized和volatile来保证程序执行过程中的原子性, 有序性, 可见性, 那么代码将会变得异常繁琐。
JMM提供了Happen-Before规则来约束数据之间是否存在竞争, 线程环境是否安全，具体如下：
* **程序次序规则：** 在一个线程内，保证语义的串行性。按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
* **管程锁定规则：** 一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一锁，而“后面”是指时间上的先后顺序。
* **volatile变量规则：** 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
* **线程启动规则：** Thread对象的start()方法先行发生于此线程的每一个动作。
* **线程终止规则：** 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
* **线程中断规则：** 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
* **对象终结规则：** 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
* **传递性：** A先于B，B先于C，那么A必然先于C.
