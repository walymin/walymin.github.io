---
layout:     post
title:      JAVA 内存区域介绍
subtitle:   JVM-Java 内存区域（运行时数据区域）划分
date:       2020-02-08
author:     Admin
header-img: assets/post-bg-java-2.jpg
catalog: true
tags:
    - Java
    - JVM
---


#### 简介-运行时数据区域
java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。除了程序计数器，其他的部分都会发生 OOM。
![6369fba2414698eeedb87391beeb6269](https://github-io-blog.oss-cn-shanghai.aliyuncs.com/github-blog/blog-img-2020/java-jvm-1581518806490.png?x-oss-process=style/watermark-yumi)

#### 区域介绍

**1. 程序计数器：** 

* 它是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。每个线程有有一个私有的程序计数器，任何时间一个线程都只会有一个方法正在执行，也就是所谓的当前方法。程序计数器存放的就是这个当前方法的虚拟机字节码指令地址。

* 如果线程正在执行的是一个Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是Native方法, 这个计数器值则为空(Undefined).
*   此内存区域是唯一 一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.。

**2. JavaJVM虚拟机栈：**

* 创建线程的时候会创建线程内的虚拟机栈，栈中存放着一个个的栈帧，对应着一个个方法的调用。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
* 局部变量表存放了编译期可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double）,对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）
 
**3. 本地方法栈**
* 跟 JVM 虚拟机栈比较类似，只不过它支持的是 Native 方法。

**4. Java堆：** 

* 堆是内存管理的核心区域，用来存放对象实例。几乎所有创建的对象实例都会直接分配到堆上（随着JIT编译器的发展与逃逸分析技术成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所以这个不绝对了）。所以堆也是垃圾回收的主要区域，垃圾收集器会对堆有着更细的划分，最常见的就是把堆划分为新生代和老年代。

**5. 方法区：**

* 方法区跟java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量（jdk8开始静态变量放在堆里面），即时编译器编译后的代码等数据。


**6. 运行时常量池：**
* jdk1.6之前运行时常量池位于方法区中，之后位于Java堆中，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入存放。

**7. 直接内存（Direct Memory）**
* 直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用。大致意思是，通过NIO类，引入了一种基于通道（Ch annel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样提高了性能，避免了在Java堆和Native堆中来回复制数据。
